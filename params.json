{"name":"Sweet-contracts","tagline":"A collection of sweet.js macros that provide contract support for JavaScript!","body":"sweet-contracts\r\n===============\r\n\r\nA collection of sweet.js macros that provide contract support for JavaScript! \r\nEnforce the runtime behavior of your code with beautiful syntax.\r\nInspired and motivated by [contracts.coffee](http://www.disnetdev.com/contracts.coffee). \r\nPowered by [contracts.js](http://disnetdev.com/contracts.js/). Made possible by [sweet.js](http://sweetjs.org).\r\n\r\nYou may notice that the syntax (and documentation...) of `sweet-contracts` bears a striking resemblance `contracts.coffee`. This is by design. The idea is to get roughly the same functionality and smooth syntax without transmogrifying existing code into CoffeeScript. Also, we wanted to present something cool you can do with `sweet.js` which you couldn't otherwise do in pure JS.\r\n\r\n###Let's start simple...\r\n\r\nTry decorating a regular old JavaScript function with a contract:\r\n\r\n    fun (Num) -> Num\r\n    function dbl(n) {\r\n        return n + n;\r\n    }\r\n\r\nSo what happens if we call `dbl` incorrectly?\r\n\r\n    > dbl(\"qux\");\r\n    Error: Contract violation: expected <Num>, \r\n    actual: \"qux\"\r\n    Value guarded in: docs.js:3:16 (value) \r\n    -- blame is on: sandbox_exp.js:3:16 (caller)\r\n    Parent contracts:\r\n    (Num) -> Num \r\n\r\nAwesome! I bet that would have been really hard to debug! How about objects and arrays?\r\n\r\n    obj { \r\n          name: Str,\r\n          age:  Num\r\n        }\r\n    var person = { name: Alyssa P. Hacker, age: 23 };\r\n\r\n    arr [Str, Num...]\r\n    var scores = ['Bo', 92, 78, 84, 95, 106];\r\n\r\nAnd don't worry, all that whitespace is totally optional. Sweet.js, the macro engine upon which sweet-contracts is based, ignores it. Of course, we can do more complicated things with our contracts:\r\n\r\n    fun ({name: Str, age: Num}, [Str, Num...]) -> (Num or Bool)\r\n    function avg_score(person, scores) {\r\n        var tmp;\r\n        if (person.name !== scores[0]) {\r\n            return false;\r\n        }\r\n        tmp = scores.slice(1).reduce(function(a,b) { \r\n            return a + b; \r\n        });\r\n        return (tmp / (scores.slice(1).length));\r\n    }\r\n\r\nYou're not restricted to a set of predefined contract combinators, either. Defining your own is as simple as writing a suitable predicate function.\r\n\r\n    var Even = check(function(x) { return x % 2 === 0; }, 'Even');\r\n    var Odd = check(function(x) { return x % 2 !== 0; }, 'Odd');\r\n\r\n    fun (Even) -> Odd\r\n    function inc(x) {\r\n        return x + 1;\r\n    }\r\n\r\nKeep in mind that slapping a contract on your function is not the magic bullet for programming in dynamic languages. The onus is still on you to write semantically robust code, but sweet-contracts aims to lighten the load a bit.\r\n\r\n###Usage\r\n\r\nThe best (and easiest) way to use sweet-contracts is to install it via npm:\r\n\r\n    npm install sweet-contracts\r\n\r\nThis should take care of any and all dependencies automagically. Now, you can go ahead and create a file `test_contracts.js`:\r\n\r\n    var contracts = require(\"contracts-js\");\r\n    setupContracts(contracts);\r\n\r\n    fun (Num) -> Num\r\n    function dbl(x) { return x + x; }\r\n\r\n    console.log(dbl(4));\r\n\r\nGo ahead and compile it using `sweet-contracts`:\r\n\r\n    $ sweet-contracts -o out.js test_contracts.js\r\n    $ node --harmony out.js\r\n    8\r\n\r\nNotice that you need to require `contracts-js` and pass it to the `setupContracts` macro any time you want to compile a file containing `sweet-contracts` syntax. This makes the module exported by `contracts.js` available to the `sweet-contracts` macros. You don't need to worry about this unless you forget those first two lines.\r\n\r\nAdditionally, `contracts.js` makes use of some experimental JavaScript features (specifically WeakMaps and Proxies). If you want to run the emitted code in node, you will need to pass the `--harmony` option. Similarly, if you want to run the code in Chrome, you will need to go to about:flags and enable experimental JavaScript (harmony features are available without flags in recent versions of Firefox).\r\n\r\n####Testing\r\n\r\nIf you want to fiddle with this project (which we hope you will), just install with the `dev` dependencies:\r\n\r\n    npm install --dev\r\n\r\nAnd run the tests:\r\n\r\n    npm test\r\n\r\n###Functions\r\n\r\nBasic functions:\r\n\r\n    fun (Num) -> Num\r\n    function f(x) { return x; }\r\n\r\nMultiple arguments:\r\n   \r\n    fun (Num, Str, Bool) -> Num\r\n    function f(n, s, b) { /*body*/ }\r\n\r\nOptional arguments:\r\n\r\n    fun (Num, Str, Bool?) -> Num\r\n    function f(n, s, b) { /*body*/ }\r\n\r\nAs usual, optional arguments should come at the end of the argument list.\r\n\r\nWe also have higher order functions:\r\n\r\n    fun ((Num) -> Bool, Num) -> Bool\r\n    function f(g, n) { /*body*/ }\r\n\r\nFunctions that *cannot* be used with `new`:\r\n\r\n    fun (Num) --> Num\r\n    function f(n) { /*body*/ }\r\n\r\n    var g = f(23);      // oops!\r\n    var g = new f(23);  // funky!\r\n\r\nAnd function that *must* be used with `new`:\r\n\r\n    fun (Num) ==> Num\r\n    function f(n) { /*body*/ }\r\n\r\n    var g = f(23);      // oops!\r\n    var g = new f(23);  // funky!\r\n\r\nWe also get dependent functions:\r\n\r\n    fun (Num) -> !(result, args) -> { return result > args[0]; }\r\n    function inc(n) { return n + 1; }\r\n\r\nAfter the function is evaluated, its result and original argument list are passed into the dependent function. If its return value is truthy, then everything is fine. Otherwise, we get a contract violation exception.\r\n\r\nThe `this` contract allows us to ensure that, when a function is called, `this` matches the given contract:\r\n\r\n    fun (Str) -> Str #{name: Str}\r\n    function f(s) { /*body*/ }\r\n\r\n    var no = { handle: \"wotan\", f: f};\r\n    var ok = { name: \"onan\", f: f};\r\n    \r\n    no.f(s);            // alright you primitive screwheads...\r\n    ok.f(s);            // groovy\r\n\r\n###Objects\r\n\r\nAs you might expect, object properties can be wrapped in various contracts:\r\n\r\n    obj {\r\n          a: Str,\r\n          b: Num,\r\n          f: (Num) -> Num\r\n        }\r\n    var o = {a: \"bob\", b: 23, f: function (x) -> { return x + 1; };\r\n\r\nBut take note that object (and array) contracts are not checked until the object it encloses is referenced. That is, you could assign a contract-violating object to `o`, but you won't get your error until you reference the field which violates the contract.\r\n\r\nNested objects and optional properties:\r\n\r\n    obj {\r\n          ob: { a: Str },\r\n          a: Num,\r\n          b: ?Str\r\n        } \r\n    var o = { ob: { a: \"baz\" }, a: 23 }; \r\n\r\nHow about a recursive object?\r\n\r\n    obj {\r\n          a: Num,\r\n          b: Self,\r\n          c: (Num) -> Self,\r\n          inner: { y: Bool, z: Self }\r\n        }\r\n    var o = { /*stuff*/ };\r\n\r\nThe `Self` contract is built into contracts.js and refers to the closest enclosing object. Remember that the `Self` contract requires only a reference to a similar object, not a reference to precisely the same object.\r\n\r\nNow let's take a look at objects with functions which have pre and post conditions:\r\n\r\n    obj {\r\n          a: Num,\r\n\t      f: (Num) -> Num | \r\n \t          pre:  !(o) -> { return o.a > 10; },\r\n              post: !(o) -> { return o.a > 20; }\r\n        }\r\n    var o = { a: 23, f: function (x) { this.a = this.a + x; } };\r\n\r\nThe pre and post conditions are parameterized by the enclosing object.\r\n\r\nObject invariants currently don't work (on account of a bug in contracts.js where undefined is passed into the invariant predicate), but here's the syntax anyway:\r\n\r\n    obj {\r\n          a: Num,\r\n          f: (Num) -> Num |\r\n              pre:  !(o) -> { return o.a > 10; },\r\n              post: !(o) -> { return o.a > 20; }\r\n        } | \r\n         invariant: !(o) -> { \r\n             return o.a > 0 && o.a < 100; \r\n         }\r\n    var o = { a: 42, f: function (x) { this.a = this.a + x; } };\r\n\r\n###Arrays\r\n\r\nBasic arrays:\r\n\r\n    arr [Num, Str, [Bool, Num]]\r\n    var a = [1, '2', [true, 23]];\r\n\r\nIt's worth noting that the outer array contract only covers the first three elements of \t`a`, and the inner array contract covers only the first two elements of `a[2]`. The following array, covered by the same contract, would be just as suitable:\r\n\r\n    var a = [1, '2', [true, 23, \"qux\"], \"whatever\"];\r\n\r\nMultiple elements of a single type:\r\n\r\n    arr [Num...]\r\n    var a = [42, 23, 93, 777, 8];\r\n\r\nThe `...` operator ensures that the array will contain only `Num`s.\r\n\r\nMixed arrays:\r\n\r\n    arr [Bool, Str, Num...]\r\n    var a = [false, \"qux\", 74, 8, 9]\r\n\r\nThis requires that the first two elements of the array pass the two single contracts at the beginning. The rest of the elements must be `Num`s. Note that, like optional function parameters, the contract with the `...` operator must be in the last position of the array contract.\r\n\r\n###Contract Operators\r\n\r\nThe `or` contract:\r\n\r\n    obj { a: Num or Str }\r\n    var o = { a: 8 }\r\n\r\nHere `o.a` must clear either the `Num` or `Str` contract. Note that since functions and object/array contracts have deferred checking (i.e. the contract is not checked until the function is called/object field is referenced), only one function/object can be used with `or`. \r\n\r\nThe `and` contract:\r\n\r\n    obj { a: Num and Even }\r\n    var o = { a: 42 }\r\n\r\nThe `a` property must pass both contracts. Just as with `or`, you can't use multiple function/object contracts with the `and` operator.\r\n\r\nIt's worth noting that, if you want to use a function contract as an operand, you must enclose it in parentheses. This is a difficulty introduced by the recursive macro definitions used to implement sweet-contracts.\r\n\r\n    obj { a: Num or ((Str)->Bool) }\r\n    var o = { a: function(s) { return s === \"quuux\"; } };\r\n\r\nOne final thing is that notions of precedence between `and` and `or`, which you might be familiar from Boolean Algebra, are absent from sweet-contracts. In any event, if you want anything more complicated than basic left associativity, you can just use parens.\r\n\r\n###Custom Contracts\r\n\r\nYou can also define your own personal contracts! There are two ways to do this.\r\n\r\nAssign a check to a variable:\r\n\r\n    var Num = check(function(x) { return typeof(x) === 'number'; }, 'Num');\r\n\r\nOr let the `check` macro save you from typing `var` for the zillionth time:\r\n\r\n    check(Str, function(x) { return typeof(x) === 'string'; }, 'Str');\r\n\r\nThe final argument to the `check` macro, a string, will serve to identify the resulting contract in exceptions resulting from its violation.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}